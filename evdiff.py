# -*- coding: utf-8 -*-
"""1_1evdiff.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qQm_lZFxiwxPu59b0GK7i04el7TAFtfP
"""

#Libs
import numpy as np
import matplotlib.pyplot as plt 
import time
from IPython.display import clear_output

pyth = True

#Constants
cuts_t = 99 
cuts_p = 99 
theta = np.linspace(-np.pi/2,np.pi/2,cuts_t).reshape(1,-1)
phi = np.linspace(-np.pi,np.pi,cuts_p).reshape(1,-1)

u = np.zeros((cuts_p,cuts_t))
v = np.zeros((cuts_p,cuts_t))
w = np.zeros((cuts_p,cuts_t))

for i in range(cuts_t):
        u[i] = np.sin(theta)*np.cos(phi[0,i])
        v[i] = np.sin(theta)*np.sin(phi[0,i])
        w[i] = np.cos(theta)

#Classes
class indi:
        def __init__(self,antenas=5,initialize=False,ev=True):
                self.nAnt = antenas
                if initialize:
                        self.getRandomVals()
                else:
                        self.distances = np.zeros((self.nAnt),np.float)
                        self.amplitudes = np.zeros((self.nAnt),np.float)
                        self.getPositions()
                if ev:
                        self.eval()

        def getRandomVals(self):
                #For distances
                self.distances = (np.random.random(self.nAnt)/2) + 0.5
                #self.amplitudes = ((np.random.random(self.nAnt)+1)*10)
                while True:
                    self.amplitudes = ((np.random.random(self.nAnt))*10)
                    signs = np.random.random(self.nAnt)
                    signs[signs<=0.5] = -1.
                    signs[signs>0.5] = 1.
                    self.amplitudes *=signs
                    if np.any(self.amplitudes==0.0):
                        pass
                    else:
                        break 
                #print("Distances; \n",self.distances)
                #print("Amplitudes:\n",self.amplitudes)
                self.getPositions()
        
        def getPositions(self):
                self.antPos = np.zeros(self.nAnt)
                for i in range(self.nAnt):
                        self.antPos[i] = np.sum(self.distances[:i+1])
                #print("Positions:\n",self.antPos)

        def globo(self,gr = False):
                global u
                real = np.zeros(u.shape)
                ima  = np.zeros(u.shape)
                self.abs  = np.zeros(u.shape)
                for i in range(self.nAnt):
                        r = self.antPos[i]*u
                        fasetotal = r*2*np.pi
                        #print(r,fasetotal)
                        #print(r.shape,fasetotal.shape)
                        real += self.amplitudes[i]*np.cos(fasetotal) 
                        ima  += self.amplitudes[i]*np.sin(fasetotal)
                        if np.isnan(real).any() or np.isnan(ima).any():
                            print("Something is bad test1")
                            raise SystemExit("Stop right there!")
                            
                self.abs = np.sqrt((real**2) + (ima**2))
                if np.isnan(self.abs).any():
                        print("Something is bad test2")
                        raise SystemExit("Stop right there!")
                #if gr:
		    


        def mean(self, gr=False):
                self.graph = np.mean(self.abs,axis=0)
                if np.isnan(self.graph).any():
                        print("Something is bad test3")
                        raise SystemExit("Stop right there!")
                #del self.abs
                a = np.ptp(self.graph)
                b = np.min(self.graph)
                c = np.max(self.graph)
                d = np.copy(self.graph)
                self.graph = (self.graph - np.min(self.graph))/np.ptp(self.graph) #Normalize
                if np.isnan(self.graph).any():
                        print(a)
                        print(b)
                        print(c)
                        print(d)
                        plt.plot(d)
                        plt.pause(0.01)
                        plt.plot(self.abs)
                        plt.show()
                        print()
                        print("Something is bad test4")
                        print(self.amplitudes)
                        print(self.antPos)
                        print(self.distances)
                        raise SystemExit("Stop right there!")
                
                if gr:
                    plt.plot(self.graph)
                    plt.show()

        def eval(self):
                global cuts_t
                ind = int((cuts_t+1)/2)-1
                self.getPositions()
                self.globo()
                cont = self.mean()
                self.mid = self.graph[ind]
                past = self.mid
                maxi = np.max(self.graph)
                idmax = ind
                #print("mid:",ind)
                #print("maxes:",self.mid,maxi)
                #plt.plot(self.graph)
                #plt.show()
                if self.mid>=maxi:
                    for i in range(idmax,self.graph.shape[0]):
                        if self.graph[i]<=0.5:
                            self.leny = (i-idmax)*2
                            break
                    else:
                        print("Len error")
                        print(self.graph[i])
                        print(self.graph[idmax],idmax)
                        plt.plot(self.graph)
                        plt.show()

                    for i in range(idmax+1,self.graph.shape[0]):
                        present = self.graph[i]
                        if present>past:
                            self.upy = np.max(self.graph[i:])
                            break
                        past = np.copy(present)
                    else:
                            self.upy = present
                else:
                    self.leny = 2000.
                    self.upy = 2. 

                return self.leny, self.upy

#Functions
def sortby(vals,n):
    vals = vals[vals[:,n].argsort()]
    return vals

def getInitPob(nPob,nAnt):
        pob = list()
        for i in range(nPob):
            pob.append(indi(antenas=nAnt,initialize=True))
        return pob

def evalu(pob):
    if type(pob) == list:
        ev = np.empty((0,1))
        for ind in pob:
            leny,upy = ind.eval()
            fnss = fitness(leny,upy)
            ev = np.vstack([ev,fnss])
        ind = np.arange(ev.shape[0]).reshape(-1,1)
        ev = np.hstack([ind,ev])
    else:
      leny,upy = pob.eval()
      ev = fitness(leny,upy)
    return ev

def fitness(leny,upy):
    upy *= 100.0
    global cuts_t
    ind = (cuts_t+1)/2
    l = leny*100/ind
    #print("D:",upy,leny)
    fnss = (upy+l)/2
    return fnss

def rulet(pond):
    pond = np.ravel(pond)
    #np.random.seed()
    npond = pond.shape[0]
    #Generar numero random
    r = np.random.random_sample()*np.random.randint(1,5)
    #Suma de la ruleta
    s = 0.0
    #Index para la seleccion
    idx = 0
    #Bucle de suma
    while True:
        s += pond[idx]
        if s>r:
            break
        else:
            idx += 1
            #Sentencia para retornar la ruleta
            if idx == npond:
                idx = 0
        #print("idx:",idx)
    return idx
      
def selection(pob,ev,nchilds): #hierarchy
    #pob : list of objects
    #ev  : evaluation of pob 1st column indexes, 2nd column ponderation
 
    pond = ev[:,1]
    pond = pond/np.max(pond)
    idxs = ev[:,0].astype(np.uint8)
    
    childs = 0
    chlist = list()
    ids = list()
    z = 0

    while childs<nchilds:
        #print(ids)
        z+=1
        idx = rulet(pond)
        #print(idx)
        idx = idxs[idx]
        #print(idx)
        if len(chlist)==0: #to avoid same childs in list
          #chlist.append([idx,pob[idx]])
          chlist.append(pob[idx])
          ids.append(idx)
          childs += 1
        else:
          #for i in range(len(chlist)):
            #if chlist[i][0]==idx:
              #break
          if idx in ids:
            #print("wrong")
            pass
          else:
            #chlist.append([idx,pob[idx]])
            chlist.append(pob[idx])
            ids.append(idx)
            childs += 1
    return chlist
        
def cross(c1,c2):
    r1 = np.random.randint(0,c1.distances.shape[0]-1)
    while True:
        r2 = np.random.randint(0,c1.amplitudes.shape[0]-1)
        if r2!=r1:
            break
    r3 = np.random.randint(0,c1.distances.shape[0]-1)
    while True:
        r4 = np.random.randint(0,c1.amplitudes.shape[0]-1)
        if r4!=r3:
            break
    
    if r1<r2:
        r11 = r1
        r22 = r2
    else:
        r11 = r2
        r22 = r1
    if r3<r3:
        r33 = r3
        r44 = r4
    else:
        r33 = r4
        r44 = r3

    c1.distances[r11:r22] = c2.distances[r11:r22]
    c1.amplitudes[r33:r44] = c2.amplitudes[r33:r44]
    return c1
    
def computeCandidate(father, childs):
    f = 0.4
    candidate = childs[1]
    #resta
    candidate.distances -= childs[2].distances
    candidate.amplitudes -= childs[2].amplitudes
    
    #Multiplicacion
    candidate.distances *= f
    candidate.amplitudes *= f
    
    #Adition
    candidate.distances += childs[0].distances
    candidate.distances = np.absolute(candidate.distances)
    candidate.distances = np.clip(candidate.distances,0.5,None)
    candidate.amplitudes += childs[0].amplitudes
    #candidate.amplitudes = np.absolute(candidate.amplitudes)
    #candidate.amplitudes = np.clip(candidate.amplitudes,1.,None)
    for i in range(candidate.amplitudes.shape[0]):
        if candidate.amplitudes[i]==0:
            candidate.amplitudes[i] += 1e-7
    if np.random.randint(0,100) < 90:
        candidate = cross(candidate,father)
    
    candidate.eval()
    
    return candidate


if __name__ == "__main__":
    #Making poblation
    generations = 1000
    antenas = 10
    print("Generating initial poblation...")
    pob = getInitPob(200,antenas)
    print("Done!")
    
    ex = 0

    #Main loop
    print("Executing diferential evolution algorithm...")
    for g in range(generations):
            time.sleep(0.1)
            #clear_output()
            
            print("Generation %d:" % g)
            np.random.seed(1)
            #Evaluation
            print("\tEvaluating...")
            ev = evalu(pob)
            #Sorting
            print("\tSorting...")
            sorty = sortby(ev,1)
            #print(sorty)
            #print(ev)
            time.sleep(1)
            print("Best result so far:")
            best = pob[int(sorty[0,0])]
            if pyth:
              plt.close('all')
            plt.plot(best.graph)
            if pyth:
              plt.pause(0.01)
            else:
              plt.show()
            print("Amplitudes: ",best.amplitudes)
            print("Ants positions: ",best.antPos)
            print("Distances: ", best.distances)
            print("\tDiferential algorithm...")
            pra = False
            for i in range(len(pob)):
                chars = 40
                por = int((i+1)*chars/len(pob))
                lef = chars-por
                uno = ">"*por
                dos = "-"*lef
                #print(uno)
                #print(dos)
                print("\t\t||",uno,dos,"|| ",int((i+1)*100/len(pob)),"%" , end='\r')
                #Selection
                pi = pob[i]
                #childs = selection(pob,sorty,3)
                childs = selection(pob,ev,3)
                can = computeCandidate(pi,childs)
                canev = evalu(can)
                piev = evalu(pi)
                #print(canev,piev,canev<piev)
                if canev<piev:
                    ex = 0
                    pra = True
                    pob[i] = can
                if pra:
                    print("Storing candidate!", end= '\r')
            ex += 1
            if ex > 20:
                print("Algorithm ended because of 20 generations without changes")
                break

with open("best_result.txt", "w+") as f:
    f.write("Amps:\n")
    for i in range(best.amplitudes.shape[0]):
       f.write("%f," % best.amplitudes[i])
    f.write("\n")
    f.write("Distances:\n")
    for i in range(best.amplitudes.shape[0]):
       f.write("%f," % best.distances[i])
    f.write("\n")
plt.savefig('Best_res.png')
