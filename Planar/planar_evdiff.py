# -*- coding: utf-8 -*-
"""1_1evdiff.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qQm_lZFxiwxPu59b0GK7i04el7TAFtfP
"""

#Libs
import numpy as np
import matplotlib.pyplot as plt 
from matplotlib import cm
import time
from mpl_toolkits.mplot3d import Axes3D
from IPython.display import clear_output

np.random.seed()

class ant:
    def __init__(self,init=False):
        self.pos = np.zeros((1,2))
        self.amp = 0.0

        if init:
            self.pos = np.random.random((1,2))*10 #range from 0 to 10
            self.amp = 0.0
            while self.amp == 0:
                #self.amp = ((np.random.random()*2)-1)*10  #range from -10 to 10
                self.amp = np.random.random()*10  #range from 0 to 10
    def posright(self,ants,md):
        for i,a in enumerate(ants):
            if a == self:
                continue
            eu =  np.sqrt(np.sum((self.pos - a.pos)**2))
            if eu < md:
                lit = (np.random.random((1,2))*2)-1 #range from -0.5 to 0.5
                #print("pos" ,self.pos.shape)
                #print("lit" ,lit.shape)
                self.pos = self.pos.reshape((1,-1))
                self.pos += lit
                #print(self.pos)
                self.pos = np.clip(self.pos,0.,10.)
                #print(self.pos)
                #print(eu)
                return False,i
        return True,-1


def posfix(ants,verbose=False,g=False,p=False):
    for i,a in enumerate(ants):
        while True:
            zz = a.posright(ants,0.5)
            if not zz[0]:
                if g:
                    plt.clf()
                    for ii,aa in enumerate(ants):
                        plt.scatter(aa.pos[0,0],aa.pos[0,1])
                    plt.legend(range(n_ants))
                if p:
                    print("Antenas collapsed")
                    p = False
                if verbose:
                    print("%d is very close to %d" % (i,zz[1]))
                if g:
                    plt.grid()
                    plt.pause(0.5)
            else:
                break
    if g:
        for i,a in enumerate(ants):
            plt.scatter(a.pos[0,0],a.pos[0,1])
        plt.legend(range(n_ants))
        plt.show()
    return ants



pyth = True

#Constants
cuts = 99
#cuts_t = 99 
#cuts_p = 99 
cuts_t = cuts
cuts_p = cuts
theta = np.linspace(-np.pi/2,np.pi/2,cuts_t).reshape(1,-1)
phi = np.linspace(-np.pi,np.pi,cuts_p).reshape(1,-1)

u = np.zeros((cuts_p,cuts_t))
v = np.zeros((cuts_p,cuts_t))
w = np.zeros((cuts_p,cuts_t))

for i in range(cuts_t):
        u[i] = np.sin(theta)*np.cos(phi[0,i])
        v[i] = np.sin(theta)*np.sin(phi[0,i])
        w[i] = np.cos(theta)


#Classes
class indi:
        def __init__(self,antenas=5,initialize=False,ev=True):
                self.nAnt = antenas
                self.ants = []
                if initialize:
                    for i in range(antenas):
                        self.ants.append(ant(True))
                    self.ants = posfix(self.ants)
                    self.getPositions()
                    self.getAmps()
                    self.globo()
                    self.eval()

        def getPositions(self):
            self.dx = np.zeros(self.nAnt)
            self.dy = np.zeros(self.nAnt)
            self.distances = np.zeros((self.nAnt,2))
            for i,ant in enumerate(self.ants):
                try:
                    self.dx[i] = ant.pos[0]
                    self.dy[i] = ant.pos[1]
                except:
                    self.dx[i] = ant.pos[0,0]
                    self.dy[i] = ant.pos[0,1]
                self.distances[i] = ant.pos


        def getAmps(self):
            self.amplitudes = np.zeros(self.nAnt)
            for i,ant in enumerate(self.ants):
                self.amplitudes[i] = ant.amp

        def updAmps(self):
            for i,a in enumerate(self.amplitudes):
                self.ants[i].amp = a
        def updDist(self):
            for i,a in enumerate(self.distances):
                self.ants[i].pos = a

        def updFarrs(self,p=False):
            self.updDist()
            self.updAmps()
            self.ants = posfix(self.ants,p=p)
            self.getPositions()

        def globo(self,gr = False,pause= 0.0):
                global u
                real = np.zeros(u.shape)
                ima  = np.zeros(u.shape)
                self.abs  = np.zeros(u.shape)
                for i in range(self.nAnt):
                        #print("awas: ",self.ants[i].pos.shape)
                        self.ants[i].pos = self.ants[i].pos.reshape(1,2)
                        r = self.ants[i].pos[0,0]*u+self.ants[i].pos[0,1]*v
                        fasetotal = r*2*np.pi
                        #print(r,fasetotal)
                        #print(r.shape,fasetotal.shape)
                        real += self.ants[i].amp*np.cos(fasetotal)
                        ima  += self.ants[i].amp*np.sin(fasetotal)
                        if np.isnan(real).any() or np.isnan(ima).any():
                            print("Something is bad test1")
                            raise SystemExit("Stop right there!")

                self.abs = np.sqrt((real**2) + (ima**2))
                self.abs = (self.abs - np.min(self.abs))/np.ptp(self.abs) #Normalize
                self.mean()
                if np.isnan(self.abs).any():
                        print("Something is bad test2")
                        raise SystemExit("Stop right there!")
                if gr:
                    #xs,ys = theta,theta
                    fig = plt.figure()
                    #ax = fig.add_subplot(111, projection='3d')
                    ax = fig.gca(projection='3d')
                    global cuts_t,theta
                    X,Y = np.meshgrid(theta.ravel(),theta.ravel())
                    Z = self.abs
                    surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm, linewidth=0, antialiased=False)
                    if pause!=0.0:
                        plt.pause(pause)
                    else:
                        plt.show()

        def mean(self, gr=False):
                self.graph = np.mean(self.abs,axis=0)
                if np.isnan(self.graph).any():
                        print("Something is bad test3")
                        raise SystemExit("Stop right there!")
                #del self.abs
                if np.isnan(self.graph).any():
                        print(a)
                        print(b)
                        print(c)
                        print(d)
                        plt.plot(d)
                        plt.pause(0.01)
                        plt.plot(self.abs)
                        plt.show()
                        print()
                        print("Something is bad test4")
                        print(self.amplitudes)
                        print(self.antPos)
                        print(self.distances)
                        raise SystemExit("Stop right there!")

                if gr:
                    plt.plot(self.graph)
                    plt.show()

        def lenylen(self,iabs,mid):
            #midval =  np.max(self.abs[iabs]) - np.min(self.abs[iabs])
            gra = self.abs[iabs]
            gra = (gra - np.min(gra))/np.ptp(gra) #Normalize
            for i in range(mid,gra.shape[0]):
                #if self.abs[iabs,i]<=0.5:
                #if self.abs[iabs,i]<=midval:
                if gra[i]<=0.5:
                    return (i-mid)*2
            else:
                print("Len error")
                #print(midval)
                plt.plot(gra)
                plt.show()
            exit()

        def eval(self):
                global cuts_t
                ind = int((cuts_t+1)/2)-1
                self.mid = self.graph[ind]
                past = self.mid
                maxi = np.max(self.graph)
                idmax = ind
                #print("mid:",ind)
                #print("maxes:",self.mid,maxi)
                #plt.plot(self.graph)
                #plt.show()
                #if self.mid>=maxi:

                sumlen = np.int(0)

                for i in range(self.abs.shape[0]):
                    sumlen += self.lenylen(i,ind)
                self.leny = sumlen

                sumups = np.float(0.)
                for ii in range(self.abs.shape[0]):
                    gra = self.abs[ii]
                    past = gra[idmax]
                    for i in range(idmax+1,gra.shape[0]):
                        present = gra[i]
                        if present>past:
                            great = np.max(gra[i:])
                            break
                        past = np.copy(present)
                    else:
                        great = past
                    sumups += great

                self.upy = sumups

                #print(sumlen,sumups)

                return self.leny, self.upy


#Functions
def sortby(vals,n):
    vals = vals[vals[:,n].argsort()]
    return vals

def getInitPob(nPob,nAnt):
        pob = list()
        for i in range(nPob):
            pob.append(indi(antenas=nAnt,initialize=True))
        return pob

def evalu(pob):
    if type(pob) == list:
        ev = np.empty((0,1))
        for ind in pob:
            leny,upy = ind.eval()
            fnss = fitness(leny,upy)
            ev = np.vstack([ev,fnss])
        ind = np.arange(ev.shape[0]).reshape(-1,1)
        ev = np.hstack([ind,ev]) #index and evaluation returned
    else:
      leny,upy = pob.eval()
      ev = fitness(leny,upy)
    return ev

def fitness(leny,upy):
    return leny+upy
#def fitness(leny,upy):
#    upy *= 100.0
#    global cuts_t
#    ind = (cuts_t+1)/2
#    l = leny*100/ind
#    #print("D:",upy,leny)
#    fnss = (upy+l)/2
#    return fnss

def rulet(pond):
    pond = np.ravel(pond)
    #np.random.seed()
    npond = pond.shape[0]
    #Generar numero random
    r = np.random.random_sample()*np.random.randint(1,5)
    #Suma de la ruleta
    s = 0.0
    #Index para la seleccion
    idx = 0
    #Bucle de suma
    while True:
        s += pond[idx]
        if s>r:
            break
        else:
            idx += 1
            #Sentencia para retornar la ruleta
            if idx == npond:
                idx = 0
        #print("idx:",idx)
    return idx

def selection(pob,ev,nchilds,elim,p=False):
    
    inds = np.arange(len(pob))
    if p:
        print("Indices:")
        print(inds)
    inds = np.delete(inds,elim,0)
    if p:
        print("Eliminate:", elim)
        print("Upd ind:")
        print(inds)
    np.random.shuffle(inds)
    inds = inds[:nchilds]

    if p:
        print("Returned indices:")
        print(inds)
    
    chls = []
    for i in inds:
        chls.append(pob[i])
    return chls

def selection2(pob,ev,nchilds): #hierarchy
    #pob : list of objects
    #ev  : evaluation of pob 1st column indexes, 2nd column ponderation

    pond = ev[:,1]
    pond = pond/np.max(pond)
    idxs = ev[:,0].astype(np.uint8)

    childs = 0
    chlist = list()
    ids = list()
    z = 0

    while childs<nchilds:
        #print(ids)
        z+=1
        idx = rulet(pond)
        #print(idx)
        idx = idxs[idx]
        #print(idx)
        if len(chlist)==0: #to avoid same childs in list
          #chlist.append([idx,pob[idx]])
          chlist.append(pob[idx])
          ids.append(idx)
          childs += 1
        else:
          #for i in range(len(chlist)):
            #if chlist[i][0]==idx:
              #break
          if idx in ids:
            #print("wrong")
            pass
          else:
            #chlist.append([idx,pob[idx]])
            chlist.append(pob[idx])
            ids.append(idx)
            childs += 1
    return chlist
        
def cross(c1,c2,p=False):
    np.random.seed()
    r1 = np.random.randint(0,c1.distances.shape[0])
    while True:
        r2 = np.random.randint(0,c1.amplitudes.shape[0])
        if r2!=r1:
            break
    r3 = np.random.randint(0,c1.distances.shape[0])
    while True:
        r4 = np.random.randint(0,c1.amplitudes.shape[0])
        if r4!=r3:
            break
    
    if r1<r2:
        r11 = r1
        r22 = r2
    else:
        r11 = r2
        r22 = r1
    if r3<r4:
        r33 = r3
        r44 = r4
    else:
        r33 = r4
        r44 = r3

    #rd1 =  r22-r11
    #rd2 =  r44-r33

    #sh1 = np.random.randint(0,c1.distances.shape[0]-1)
    #sh2 = np.random.randint(0,c1.amplitudes.shape[0]-1)

    #for i in range(r11,r22):
    #    ind = (i+sh1) % c1.distances.shape[0]
    #    c1.distances[ind] = c2.distances[i]
    #for i in range(r33,r44):
    #    ind = (i+sh2) % c1.amplitudes.shape[0]
    #    c1.amplitudes[ind] = c2.amplitudes[i]
    
    if p:
        print("Dist indices:")
        print(r11,r22)
        print("Amps indices:")
        print(r33,r44)

        print("Distances:")
        print("c1.orig")
        print(c1.distances)
        print("c2.orig")
        print(c2.distances)
    c1.distances[r11:r22] = c2.distances[r11:r22]
    if p:
        print("c1.cross")
        print(c1.distances)
        print("Amplitudes:")
        print("c1.orig")
        print(c1.amplitudes)
        print("c2.orig")
        print(c2.amplitudes)
    c1.amplitudes[r33:r44] = c2.amplitudes[r33:r44]
    if p:
        print("c1.cross")
        print(c1.amplitudes)
        print("Updating values")
    c1.updFarrs()
    if p:
        print("c1.updated")
        print(c1.distances)
        print(c1.amplitudes)
    return c1
    
def computeCandidate(father, childs):
    f = 0.4
    candidate = childs[1]
    past1 = candidate.amplitudes
    past2 = candidate.distances
    #resta
    candidate.distances -= childs[2].distances
    candidate.amplitudes -= childs[2].amplitudes

    #Multiplicacion
    candidate.distances *= f
    candidate.amplitudes *= f

    #Adition
    candidate.distances += childs[0].distances
    candidate.distances = np.absolute(candidate.distances)
    candidate.distances = np.clip(candidate.distances,0.,10.)
    candidate.amplitudes += childs[0].amplitudes
    candidate.amplitudes = np.absolute(candidate.amplitudes)
    candidate.amplitudes = np.clip(candidate.amplitudes,1e-7,None)
    for i in range(candidate.amplitudes.shape[0]):
        if candidate.amplitudes[i]==0:
            candidate.amplitudes[i] += 1e-7

    #print(np.all(candidate.amplitudes==past1))
    #print(np.all(candidate.distances==past2))
    past1 = candidate.amplitudes
    past2 = candidate.distances
    candidate.updFarrs()#True)
    #if not np.all(candidate.amplitudes==past1):
    #    exit()
    #if not np.all(candidate.distances==past2):
    #    exit()
    #exit()
    if np.random.randint(0,100) < 90:
        candidate = cross(candidate,father)#,True)

    candidate.eval()

    return candidate



if __name__ == "__main__":
    #Making poblation
    generations = 100
    npob = 100
    #generations = 1000
    antenas = 10
    print("Generating initial poblation...")
    pob = getInitPob(npob,antenas)
    print("Done!")

    ex = 0

    #Main loop
    print("Executing diferential evolution algorithm...")
    for g in range(generations):
            time.sleep(0.1)
            #clear_output()

            print("Generation %d:" % g)
            np.random.seed()
            #indices = np.arange(len(pob))
            #np.random.shuffle(indices)
            #pob2 = []
            #for i in indices:
            #    pob2.append(pob[i])
            #pob = pob2
            #np.random.seed()
            #Evaluation
            print("\tEvaluating...")
            ev = evalu(pob)
            #Sorting
            print("\tSorting...")
            sorty = sortby(ev,1)
            print(sorty[:,0].astype(np.uint8))
            print(sorty[:,1].astype(float))

            for iii,p in enumerate(pob):
               print("Indi %d:" % iii)
               print(p.distances)
               print(p.amplitudes)

            #print(ev)
            time.sleep(1)
            print("Best result so far:")
            best = pob[int(sorty[0,0])]
            if pyth:
              plt.close('all')
            best.globo(True,0.5)
            print("Amplitudes: ")
            for ant in best.ants:
                print("%f " % ant.amp, end='')
            print("\nAnts positions: \n\tx\t\ty")
            for ant in best.ants:
                print(ant.pos)
            
            print("\n\tDiferential algorithm...")
            pra = False
            for i in range(len(pob)):
                chars = 40
                por = int((i+1)*chars/len(pob))
                lef = chars-por
                uno = ">"*por
                dos = "-"*lef
                #print(uno)
                #print(dos)
                print("\t\t||",uno,dos,"|| ",int((i+1)*100/len(pob)),"%" , end='\r')
                #Selection
                pi = pob[i]
                #childs = selection(pob,sorty,3)
                #childs = selection(pob,ev,3)
                childs = selection(pob,ev,3,i)#,True)
                can = computeCandidate(pi,childs)
                canev = evalu(can)
                piev = evalu(pi)
                #print(canev,piev,canev<piev)
                if canev<piev:
                    ex = 0
                    pra = True
                    pob[i] = can
                if pra:
                    print("Storing candidate!", end= '\r')
            ex += 1
            if ex > 20:
                print("Algorithm ended because of 20 generations without changes")
                break

with open("best_result.txt", "w+") as f:
    f.write("Amps:\n")
    for i in range(best.amplitudes.shape[0]):
       f.write("%f," % best.amplitudes[i])
    f.write("\n")
    f.write("Distances:\n")
    for i in range(best.amplitudes.shape[0]):
       f.write("%s," % str(best.distances[i]))
    f.write("\n")
plt.savefig('Best_res.png')
